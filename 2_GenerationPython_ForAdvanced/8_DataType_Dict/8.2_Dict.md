# Тема урока: словари в Python

1. Встроенные функции _len(), sum(), min(), max()_
2. Оператор принадлежности _in_
3. Перебор словарей
4. Распаковка словаря
5. Форматированный вывод словарей
6. Сравнение словарей
7. Методы _keys(), values() и items()_

**Аннотация**. В этом уроке мы изучим основной функционал при работе со словарями.

## Основы работы со словарями

Работа со словарями похожа на работу со списками, поскольку и словари, и списки содержат в качестве отдельных элементов пары: в словарях _ключ: значение_, в списках _индекс: значение_.

### Функция len()

**Длиной словаря** называется количество его элементов. Для определения длины словаря используют встроенную функцию _len()_ (от слова length – длина).

Следующий программный код:

```python
fruits = {'Apple': 70, 'Grape': 100, 'Banana': 80}
capitals = {'Россия': 'Москва', 'Франция': 'Париж'}

print(len(fruits))
print(len(capitals))
```

выведет:

```python
3
2
```

### Оператор принадлежности in

Оператор _in_ позволяет проверить, содержит ли словарь заданный **ключ**.

Рассмотрим код:

```python
capitals = {'Россия': 'Москва', 'Франция': 'Париж', 'Чехия': 'Прага'}

if 'Франция' in capitals:
    print('Столица Франции - это', capitals['Франция'])
```

Такой код проверяет, содержит ли словарь _capitals_ элемент с ключом Франция и выводит соответствующий текст:

```python
Столица Франции - это Париж
```

Можно использовать оператор _in_ вместе с логическим оператором _not_.

Не забывайте, что при обращении по **несуществующему ключу**, возникнет ошибка во время выполнения программы.

Приведенный ниже код:

```python
capitals = {'Россия': 'Москва', 'Франция': 'Париж', 'Чехия': 'Прага'}

print(capitals['Англия'])
```

приводит к возникновению ошибки:

```python
KeyError: 'Англия'
```

Оператор принадлежности _in_ на словарях работает **очень быстро**, намного быстрее, чем на списках, поэтому если нужен многократный поиск в коллекции данных, словарь – подходящий выбор.

### Встроенные функции sum(), min(), max()

Встроенная функция _sum()_ принимает в качестве аргумента **словарь с числовыми ключами** и вычисляет сумму его ключей.

Следующий программный код:

```python
my_dict = {10: 'Россия', 20: 'США', 30: 'Франция'}

print('Сумма всех ключей словаря =', sum(my_dict))
```

выводит:

```python
Сумма всех ключей словаря = 60
```

Для корректной работы функции _sum()_ ключами словаря должны быть именно числа.

Встроенные функции _min()_ и _max()_ принимают в качестве аргумента словарь и находят минимальный и максимальный ключ соответственно, при этом ключ может принадлежать к любому типу данных, для которого возможны операции порядка _<, <=, >, >=_ (числа, строки, и т.д.).

Приведенный ниже код:

```python
capitals = {'Россия': 'Москва', 'Франция': 'Париж', 'Чехия': 'Прага'}
months = {1: 'Январь', 2: 'Февраль', 3: 'Март'}

print('Минимальный ключ =', min(capitals))
print('Максимальный ключ =', max(months))
```

выводит:

```python
Минимальный ключ = Россия
Максимальный ключ = 3
```

### Сравнение словарей

Словари можно сравнивать между собой. Равные словари имеют одинаковое количество элементов и содержат равные элементы (_ключ: значение_). Для сравнения словарей используются операторы _== и !=_.

Приведенный ниже код:

```python
months1 = {1: 'Январь', 2: 'Февраль'}
months2 = {1: 'Январь', 2: 'Февраль', 3: 'Март'}
months3 = {3: 'Март', 1: 'Январь', 2: 'Февраль'}

print(months1 == months2)
print(months2 == months3)
print(months1 != months3)
```

выводит:

```python
False
True
True
```

## Примечания

**Примечание 1**. Обращение по индексу и срезы **недоступны** для словарей.

**Примечание 2**. Операция конкатенации _+_ и умножения на число _\*_ недоступны для словарей.

**Примечание 3**. Словари нужно использовать в следующих случаях:

- Подсчет числа каких-то объектов. В этом случае нужно завести словарь, в котором ключи — названия объектов, а значения — их количество.
- Хранение каких-либо данных, связанных с объектом. Ключи — наименования объектов, значения — связанные с ними данные. Например, если нужно по названию месяца определить его порядковый номер, то это можно сделать при помощи словаря _num = {'January': 1, 'February': 2, 'March': 3, ...}_.
- Установка соответствия между объектами (например, “родитель-потомок”). Ключ — объект, значение — соответствующий ему объект.
- Если нужен обычный список, где максимальное значение индекса элемента очень велико, но при этом используются не все возможные индексы (так называемый “разреженный список”), то для экономии памяти можно использовать словарь.

## Перебор элементов словаря

Перебор элементов словаря осуществляется так же, как и перебор элементов списка – с помощью цикла _for_.

Для вывода ключей словаря **каждого на отдельной строке** можно использовать следующий код:

```python
capitals = {'Россия': 'Москва', 'Франция': 'Париж', 'Чехия': 'Прага'}

for key in capitals:
    print(key)
```

Приведенный выше код выводит (порядок элементов может отличаться):

```python
Россия
Франция
Чехия
```

Для вывода значений словаря **каждого на отдельной строке** можно использовать следующий код:

```python
capitals = {'Россия': 'Москва', 'Франция': 'Париж', 'Чехия': 'Прага'}

for key in capitals:
    print(capitals[key])
```

Приведенный выше код выводит (порядок элементов может отличаться):

```python
Москва
Париж
Прага
```

Для вывода элементов словаря **каждого на отдельной строке** можно использовать следующий код:

```python
capitals = {'Россия': 'Москва', 'Франция': 'Париж', 'Чехия': 'Прага'}

for key in capitals:
    print('Столица', key, '- это', capitals[key])
```

Приведённый выше код выводит (порядок элементов может отличаться):

```python
Столица Россия - это Москва
Столица Франция - это Париж
Столица Чехия - это Прага
```

## Методы keys(), values(), items()

Словарный метод _keys()_ возвращает **список ключей** всех элементов словаря.

Следующий программный код:

```python
capitals = {'Россия': 'Москва', 'Франция': 'Париж', 'Чехия': 'Прага'}

for key in capitals.keys():     # итерируем по списку ['Россия', 'Франция', 'Чехия']
    print(key)
```

выводит (порядок элементов может отличаться):

```python
Россия
Франция
Чехия
```

Словарный метод _values()_ возвращает **список значений** всех элементов словаря.

Следующий программный код:

```python
capitals = {'Россия': 'Москва', 'Франция': 'Париж', 'Чехия': 'Прага'}

for value in capitals.values():     # итерируем по списку ['Москва', 'Париж', 'Прага']
    print(value)
```

выводит (порядок элементов может отличаться):

```python
Москва
Париж
Прага
```

Словарный метод _items()_ возвращает список всех элементов словаря, состоящий из кортежей пар _(ключ, значение)_.

Приведенный ниже код:

```python
capitals = {'Россия': 'Москва', 'Франция': 'Париж', 'Чехия': 'Прага'}

for item in capitals.items():
    print(item)
```

выводит (порядок элементов может отличаться):

```python
('Россия', 'Москва')
('Франция', 'Париж')
('Чехия', 'Прага')
```

Используя магию распаковки кортежей, можно писать такой код:

```python
capitals = {'Россия': 'Москва', 'Франция': 'Париж', 'Чехия': 'Прага'}

for key, value in capitals.items():
    print(key, '-', value)
```

Приведенный выше код выводит (порядок элементов может отличаться):

```python
Россия - Москва
Франция - Париж
Чехия - Прага
```

### Распаковка ключей словаря

Если требуется вывести только значение ключей словаря, то мы также можем использовать операцию **распаковки словаря**.

Приведенный ниже код:

```python
capitals = {'Россия': 'Москва', 'Франция': 'Париж', 'Чехия': 'Прага'}

print(*capitals, sep='\n')
```

выводит (порядок элементов может отличаться):

```python
Россия
Франция
Чехия
```

Начиная с версии Python 3.6 словари являются упорядоченными, то есть сохраняют порядок следования ключей в порядке их внесения в словарь.

### Сортировка словаря

Так как словарь состоит из пар, то и отсортировать его можно как по ключам, так и по значениям.

Сортировка по ключам выполняется с использованием функции _sorted()_.

Приведенный ниже код:

```python
capitals = {'Россия': 'Москва', 'Англия': 'Лондон', 'Чехия': 'Прага', 'Бразилия':'Бразилиа'}

for key in sorted(capitals):
    print(key)
```

гарантированно выводит ключи словаря в алфавитном порядке, по возрастанию:

```python
Англия
Бразилия
Россия
Чехия
```

Обратите внимание: функция _sorted()_ возвращает отсортированный список ключей, а не словарь. Не путайте встроенную функцию _sorted()_ и списочный метод _sort()_. Словари **не содержат** метода _sort()_.

Для сортировки словаря по значениям можно использовать функцию _sorted()_ вместе с методом _items()_.

Приведенный ниже код:

```python
capitals = {'Россия': 'Москва', 'Англия': 'Лондон', 'Чехия': 'Прага', 'Бразилия': 'Бразилиа'}

for key, value in sorted(capitals.items(), key = lambda x: x[1]):
    print(value)
```

гарантированно выводит значения словаря в алфавитном порядке, по возрастанию:

```python
Бразилиа
Лондон
Москва
Прага
```

Стоит учитывать, что _sorted(capitals.items(), key= lambda x: x[1])_ возвращает не словарь, а отсортированный по значению список кортежей.

При сортировке словаря по значениям, мы используем анонимную функцию _lambda x: x[1]_, о ней будет рассказано в следующих уроках.

## Примечания

**Примечание 1**. Как мы уже знаем, с помощью оператора принадлежности in можно быстро проверить наличие ключа в словаре. Для проверки наличия значения в словаре можно использовать оператор in вместе с методом values(), который возвращает список всех значений словаря.

**Проверка наличия ключа в словаре**:

```python
capitals = {'Россия': 'Москва', 'Франция': 'Париж', 'Чехия': 'Прага'}

if 'Россия' in capitals:
    print('В словаре есть ключ Россия')
```

**Проверка наличия значения в словаре**:

```python
capitals = {'Россия': 'Москва', 'Франция': 'Париж', 'Чехия': 'Прага'}

if 'Париж' in capitals.values():
    print('В словаре есть значение Париж')
```

**Примечание 2**. Встроенная функция _sorted()_ имеет опциональный параметр _reverse_. Если установить этот параметр в значение _True_, то сортировка будет по убыванию.

**Примечание 3**. Код для работы со словарями нужно писать таким образом, чтобы он правильно работал при любом порядке обхода с помощью цикла _for_.

**Примечание 4**. Словарные методы _items(), keys(), values()_ возвращают не совсем обычные списки. Тип этих списков – _dict_keys_ в отличие от обычных списков _list_. Методы обычных списков недоступны для списков типа _dict_keys_. Используйте явное преобразование с помощью функции _list()_ для получения доступа к методам списков.
