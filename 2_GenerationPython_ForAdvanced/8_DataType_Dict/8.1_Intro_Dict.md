# Тема урока: словари в Python

1. Новый тип коллекции
2. Отличия словарей от списков
3. Создание словарей
4. Обращение по ключу
5. Встроенная функция _dict()_
6. Создание словарей на основе списков и кортежей
7. Пустой словарь
8. Вывод словаря
9. Особенности словарей

**Аннотация**. В этом уроке мы начнем изучение словарей в Python, тип данных – _dict_. Этот тип данных похож на списки и применяется при решении многих задач.

## Словари

В прошлых уроках мы изучили четыре типа коллекций в Python:

- списки – изменяемые коллекции элементов, индексируемые;
- строки – неизменяемые коллекции символов, индексируемые;
- кортежи – неизменяемые коллекции элементов, индексируемые;
- множества – изменяемые коллекции уникальных элементов, неиндексируемые.

Следующий тип – **словари** – изменяемые коллекции элементов с **произвольными индексами – ключами**. Если в списках элементы индексируются целыми числами, начиная с 0, то в словарях — любыми ключами, в том числе в виде строк.

Как нам уже известно, списки — удобный и самый популярный способ хранения большого количества данных в одной переменной. Списки индексируют все хранящиеся в них элементы, что позволяет быстро обращаться к элементу, зная его индекс.

Приведенный ниже код:

```python
languages = ['Python', 'C#', 'Java', 'C++']

print(languages[0])
print(languages[2])
```

выводит:

```python
Python
Java
```

Допустим, мы хотим хранить имя создателя каждого языка программирования. Это можно сделать несколькими способами.

**Способ 1**. Хранить еще один список, где по соответствующему индексу будет находиться имя создателя языка программирования.

Приведенный ниже код:

```python
languages = ['Python', 'C#', 'Java', 'C++']
creators = ['Гвидо ван Россум', 'Андерс Хейлсберг', 'Джеймс Гослинг', 'Бьёрн Страуструп']

print('Создателем языка', languages[0], 'является', creators[0])
```

выводит:

```python
Создателем языка Python является Гвидо ван Россум
```

Подход рабочий, но хранить данные в двух коллекциях не очень удобно.

**Способ 2**. Хранить список кортежей с парами значений "язык - имя создателя" в каждом.

Приведенный ниже код:

```python
languages = [('Python', 'Гвидо ван Россум'),
             ('C#', 'Андерс Хейлсберг'),
             ('Java', 'Джеймс Гослинг'),
             ('C++', 'Бьёрн Страуструп')]

print('Создателем языка', languages[2][0], 'является', languages[2][1])
```

выводит:

```python
Создателем языка Java является Джеймс Гослинг
```

Тоже рабочий подход, однако не очень эффективный. Придется написать цикл _for_ для поиска по всем элементам списка _languages_ кортежа, первый элемент которого равен искомому (названию языка). Чтобы найти автора языка C++ , нужно будет в цикле пройти мимо Python, C# и Java. Не получится угадать заранее, что язык C++ лежит после них.

Приведенный ниже код:

```python
languages = [('Python', 'Гвидо ван Россум'),
             ('C#', 'Андерс Хейлсберг'),
             ('Java', 'Джеймс Гослинг'),
             ('C++', 'Бьёрн Страуструп')]

for item in languages:
    if item[0] == 'C++':
        print('Создателем языка', item[0], 'является', item[1])
```

выводит:

```python
Создателем языка C++ является Бьёрн Страуструп
```

Списки индексируются целыми числами, но в этом случае удобно было бы находить информацию не по числу, а по строке — названию языка программирования. В списках строки не могут быть индексами, однако в словарях это возможно.

Словарь (тип данных _dict_), как и список, позволяет хранить много данных. В отличие от списка, в словаре для каждого элемента можно произвольно определить «индекс» — **ключ**, по которому он будет доступен.

Словарь — реализация структуры данных "ассоциативный массив" или "хеш таблица". В других языках аналогичная структура называется _map, HashMap, Dictionary_.

## Создание словаря

Чтобы создать словарь, нужно перечислить его элементы – пары ключ-значение – через запятую в фигурных скобках, как и элементы множества. Первым указывается ключ, после двоеточия — значение, доступное в словаре по этому ключу.

Приведенный ниже код:

```python
languages = {'Python': 'Гвидо ван Россум',
             'C#': 'Андерс Хейлсберг',
             'Java': 'Джеймс Гослинг',
             'C++': 'Бьёрн Страуструп'}
```

создает словарь, в котором ключом служит строка — название языка программирования, а значением — имя создателя языка.

## Обращение к элементу словаря

Извлечь значение элемента словаря можно, обратившись к нему по его ключу. Чтобы получить значение по заданному ключу, как и в списках, используем квадратные скобки _[]_ , индексируем по ключу.

**Способ 3**. Приведенный ниже код:

```python
languages = {'Python': 'Гвидо ван Россум',
             'C#': 'Андерс Хейлсберг',
             'Java': 'Джеймс Гослинг',
             'C++': 'Бьёрн Страуструп'}

print('Создателем языка C# является', languages['C#'])
```

выводит:

```python
Создателем языка C# является Андерс Хейлсберг
```

В отличие от списков, номеров позиций в словарях нет.

Приведенный ниже код:

```python
languages = {'Python': 'Гвидо ван Россум',
             'C#': 'Андерс Хейлсберг',
             'Java': 'Джеймс Гослинг',
             'C++': 'Бьёрн Страуструп'}

print('Создателем языка C# является', languages[1])
```

приводит к возникновению ошибки _KeyError_.

Ошибка _KeyError_ возникнет и при попытке извлечь значение по несуществующему ключу. В качестве ключа можно указать выражение: Python вычислит его значение и обратится к искомому элементу.

**Способ 4**. Приведенный ниже код:

```python
languages = {'Python': 'Гвидо ван Россум',
             'C#': 'Андерс Хейлсберг',
             'Java': 'Джеймс Гослинг',
             'C++': 'Бьёрн Страуструп'}

print('Создателем языка C# является', languages['C' + '#'])
```

выводит:

```python
Создателем языка C# является Андерс Хейлсберг
```

## Создание словаря с помощью функции dict()

Если ключи словаря — строки без каких-либо специальных символов, то для создания словаря можно использовать функцию dict().

Приведенный ниже код:

```python
info = dict(name='Timur', age=28, job='Teacher')
```

создает словарь с тремя элементами, ключами которого служат строки _'name', 'age', 'job'_, а значениями – _'Timur', 28, 'Teacher'_.

## Создание словаря на основании списков и кортежей

Создавать словари можно на основе списков кортежей или кортежей списков. Первый элемент списка или кортежа станет ключом, второй — значением.

Приведенный ниже код:

```python
info_list = [('name', 'Timur'), ('age', 28), ('job', 'Teacher')]  # список кортежей

info_dict = dict(info_list)  # создаем словарь на основе списка кортежей
```

создает словарь с тремя элементами, где ключи — строки _name, age, job_, а соответствующие им значения — _'Timur', 28, 'Teacher'_.

Аналогично работает приведенный ниже код:

```python
info_tuple = (['name', 'Timur'], ['age', 28], ['job', 'Teacher'])  # кортеж списков

info_dict = dict(info_tuple)  # создаем словарь на основе кортежа списков
```

Если необходимо создать словарь, каждому ключу которого соответствует одно и то же значение, можно воспользоваться методом _fromkeys()_.

Приведенный ниже код:

```python
dict1 = dict.fromkeys(['name', 'age', 'job'], 'Missed information')
```

создает словарь с тремя элементами, где ключи — строки _'name', 'age', 'job'_, а соответствующие им значения: _'Missed information', 'Missed information', 'Missed information'_.

Если методу _fromkeys()_ не передать второй параметр, то по умолчанию присваивается значение _None_.

Приведенный ниже код:

```python
dict1 = dict.fromkeys(['name', 'age', 'job'])
```

создает словарь с тремя элементами, в которых ключи — строки _'name', 'age', 'job'_, а значения — _None, None, None_.

## Пустой словарь

**Пустой словарь** можно создать двумя способами:

- с помощью пустых фигурных скобок;
- с помощью функции _dict()_.

Приведенный ниже код:

```python
dict1 = {}
dict2 = dict()


print(dict1)
print(dict2)
print(type(dict1))
print(type(dict2))
```

создает два пустых словаря и выводит:

```python
{}
{}
<class 'dict'>
<class 'dict'>
```

Вспомните, что создать пустое множество можно, только используя функцию _set()_, потому что пустые фигурные скобки зарезервированы для создания словаря.

## Вывод словаря

Для вывода всего словаря можно использовать функцию _print()_:

```python
languages = {'Python': 'Гвидо ван Россум',
             'C#': 'Андерс Хейлсберг',
             'Java': 'Джеймс Гослинг'}

info = dict(name = 'Timur', age = 28, job = 'Teacher')

print(languages)
print(info)
```

Функция _print()_ выводит на экран элементы словаря в фигурных скобках, разделенные запятыми:

```python
{'Python': 'Гвидо ван Россум', 'C#': 'Андерс Хейлсберг', 'Java': 'Джеймс Гослинг'}
{'name': 'Timur', 'age': 28, 'job': 'Teacher'}
```

Начиная с версии Python 3.6, словари являются упорядоченными, то есть сохраняют порядок следования ключей в порядке их внесения в словарь.

# Примечания

**Примечание 1**. Словари принципиально отличаются от списков по структуре хранения в памяти. Список — последовательная область памяти, то есть все его элементы (указатели на элементы) действительно хранятся в указанном порядке, расположены последовательно. Благодаря этому и можно быстро «прыгнуть» к элементу по его индексу. В словаре же используется специальная структура данных — **хеш-таблица**. Она позволяет вычислять числовой хеш от ключа и использовать обычные списки, где в качестве индекса элемента берется этот хеш.

**Примечание 2**. В рамках одного словаря каждый ключ уникален.

**Примечание 3**. Словари удобно использовать для хранения различных сущностей. Например, если нужно работать с информацией о человеке, то можно хранить все необходимые сведения, включающие такие разные сущности как "возраст", "профессия", "название города", "адрес электронной почты" в одном словаре **info** и легко обращаться к его элементам по ключам:

```python
info = {'name': 'Timur',
        'age': 28,
        'job': 'Teacher',
        'city': 'Moscow',
        'email': 'timyr-guev@yandex.ru'}

print(info['name'])
print(info['email'])
```

**Примечание 4**. Создать словарь на основании двух списков (кортежей) можно с помощью встроенной функции-упаковщика _zip()_, о которой расскажем позже.

Приведенный ниже код:

```python
keys = ['name', 'age', 'job']
values = ['Timur', 28, 'Teacher']

info = dict(zip(keys, values))

print(info)
```

выводит (порядок элементов может отличаться):

```python
{'name': 'Timur', 'age': 28, 'job': 'Teacher'}
```

В случае несовпадения длины списков функция самостоятельно отсечет лишние элементы.
