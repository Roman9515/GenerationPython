# Тема урока: генераторы множеств, frozenset

1. Генераторы множеств
2. Неизменяемые множества _frozenset_

**Аннотация**. Урок посвящен генераторам множеств и типу данных _frozenset_.

## Генераторы множеств

Пусть требуется создать множество, содержащее цифры введенного числа.

Следующий программный код:

```python
digits = set(int(input()))
```

приводит к ошибке

```python
TypeError: 'int' object is not iterable
```

поскольку функция _set()_ принимает в качестве аргумента итерируемый объект, а число (тип данных _int_) таковым не является.

Следующий программный код:

```python
digits = set(input())
```

при вводе строки _'12345'_ создает множество символов _{'1', '2', '3', '4', '5'}_, а не множество цифр _{1, 2, 3, 4, 5}_.

Для создания требуемого множества, содержащего уникальные цифры введенного числа, нам придется написать код:

```python
digits = set()

for c in input():
    digits.add(int(c))
```

Такой код хоть и не сложен, однако достаточно громоздок.

Для создания множеств в Python можно использовать специальный синтаксис, как при создании списка.

Приведенный выше код можно переписать с использованием генератора множеств:

```python
digits = {int(c) for c in input()}
```

Общий вид генератора множеств следующий:

```python
{выражение for переменная in последовательность},
```

где _выражение_ — некоторое выражение, как правило, зависящее от использованной в списочном выражении переменной, которым будут заполнены элементы множества _переменная_ — имя некоторой переменной, _последовательность_ — последовательность значений, которые она принимает (любой итерируемый объект).

## Примеры использования генератора множеств

1. **Создать множество, заполненное квадратами целых чисел от 0 до 9, можно так**:

```python
squares = {i ** 2 for i in range(10)}
```

2. **Создать множество, заполненное кубами целых чисел от 10 до 20, можно так**:

```python
cubes = {i ** 3 for i in range(10, 21)}
```

3. **Создать множество, заполненное символами строки, можно так**:

```python
chars = {c for c in 'abcdefg'}
```

## Условия в генераторе множеств

В генераторах множеств можно использовать условный оператор. Например, если требуется создать множество, заполненное только цифрами некоторой строки, то мы можем написать такой код:

```python
digits = {int(d) for d in 'abcd12ef78ghj90' if d.isdigit()}
```

# Frozenset

Замороженное множество (_frozenset_) также является встроенной коллекцией в Python. Обладая характеристиками обычного множества, замороженное множество не может быть изменено после создания.

Кортеж (тип _tuple_) – неизменяемая версия списка (тип _list_), а замороженное множество (тип _frozenset_) – неизменяемая версия обычного множества (тип _set_).

Для создания замороженного множества используется встроенная функция _frozenset()_, которая принимает в качестве аргумента другую коллекцию.

Приведенный ниже код:

```python
myset1 = frozenset({1, 2, 3})                         # на основе множества
myset2 = frozenset([1, 1, 2, 3, 4, 4, 4, 5, 6, 6])    # на основе списка
myset3 = frozenset('aabcccddee')                      # на основе строки

print(myset1)
print(myset2)
print(myset3)
```

выводит:

```python
frozenset({1, 2, 3})
frozenset({1, 2, 3, 4, 5, 6})
frozenset({'e', 'd', 'c', 'b', 'a'})
```

## Операции над замороженными множествами

Над замороженными множествами можно производить все операции, которые можно производить над обычными множествами:

- объединение множеств: метод _union()_ или оператор _|_;
- пересечение множеств: метод _intersection()_ или оператор _&_;
- разность множеств: метод _difference()_ или оператор _-_;
- симметрическая разность множеств: метод _symmetric_difference()_ или оператор _^_.

Приведенный ниже код:

```python
myset1 = frozenset('hello')
myset2 = frozenset('world')

print(myset1 | myset2)
print(myset1 & myset2)
print(myset1 ^ myset2)
```

выводит:

```python
frozenset({'l', 'w', 'e', 'h', 'r', 'd', 'o'})
frozenset({'l', 'o'})
frozenset({'d', 'h', 'w', 'e', 'r'})
```

Результатом операций над замороженными множествами будут тоже замороженные множества.

# Примечания

**Примечание 1**. Будучи изменяемыми, обычные множества не могут быть элементами других множеств. Замороженные множества являются неизменяемыми, а значит могут быть элементами других множеств.

Приведенный ниже код:

```python
sentence = 'The cat in the hat had two sidekicks, thing one and thing two.'

words = sentence.lower().replace('.', '').replace(',', '').split()

vowels = ['a', 'e', 'i', 'o', 'u']

consonants = {frozenset({letter for letter in word if letter not in vowels}) for word in words}

print(*consonants, sep='\n')
```

выводит (порядок элементов может отличаться):

```python
frozenset({'d', 'h'})
frozenset({'h', 't'})
frozenset({'n', 'h', 'g', 't'})
frozenset({'n'})
frozenset({'c', 't'})
frozenset({'n', 'd'})
frozenset({'w', 't'})
frozenset({'s', 'c', 'k', 'd'})
```

**Примечание 2**. Методы, изменяющие множество, отсутствуют у замороженных множеств:

- add()
- remove()
- discard()
- pop()
- clear()
- update()
- intersection_update()
- difference_update()
- symmetric_difference_update()

**Примечание 3**. Мы можем сравнивать простые (тип _set_) и замороженные множества (тип _frozenset_).

Приведенный ниже код:

```python
myset1 = set('qwerty')
myset2 = frozenset('qwerty')

print(myset1 == myset2)
```

выведет:

```python
True
```
